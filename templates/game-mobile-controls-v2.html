{% extends "base.html" %}

{% block content %}
<div id="gameContainer" class="game-container">
    <canvas id="gameCanvas" width="800" height="600" style="background: #002200;"></canvas>
</div>

<!-- Professional Dark Theme HUD -->
<div class="game-hud">
    <div class="hud-item">
        <span style="color: var(--color-text-secondary);">SCORE:</span> 
        <span id="score" style="color: var(--color-retro-primary); font-weight: 600;">0</span>
    </div>
    <div class="hud-item">
        <span style="color: var(--color-text-secondary);">LIVES:</span> 
        <span id="lives" style="color: var(--color-retro-success); font-weight: 600;">3</span>
    </div>
    <div class="hud-item">
        <span style="color: var(--color-text-secondary);">WEAPON:</span> 
        <span id="weapon" style="color: var(--color-retro-secondary); font-weight: 600;">PULSE</span>
    </div>
    <div class="hud-item" id="health-display">
        <span style="color: var(--color-text-secondary);">HEALTH:</span> 
        <span id="health" style="color: var(--color-retro-success); font-weight: 600;">100</span>
    </div>
</div>

<!-- Responsive Mobile Controls with Portrait/Landscape Optimization -->
<div id="mobile-controls" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000;">
    <!-- Left Control Zone - Virtual Joystick -->
    <div id="left-control" class="mobile-control-joystick" style="position: absolute; left: 20px; bottom: 20px; width: 150px; height: 150px; pointer-events: auto;">
        <canvas id="joystick-canvas" width="150" height="150" style="border-radius: 50%; background: rgba(0, 100, 0, 0.2); border: 2px solid #00ff00;"></canvas>
    </div>
    
    <!-- Right Control Zone - Fire Button -->
    <div id="right-control" class="mobile-control-fire" style="position: absolute; right: 20px; bottom: 20px; width: 100px; height: 100px; pointer-events: auto;">
        <canvas id="fire-canvas" width="100" height="100" style="border-radius: 50%; background: rgba(100, 0, 0, 0.2); border: 2px solid #ff0000;"></canvas>
    </div>
    
    <!-- Fullscreen Toggle for Mobile -->
    <div id="fullscreen-control" style="position: absolute; top: 10px; right: 10px; pointer-events: auto; display: none;">
        <button id="fullscreen-btn" style="padding: 8px 12px; background: rgba(0, 100, 0, 0.8); border: 1px solid #00ff00; color: #00ff00; border-radius: 4px; font-size: 16px;">⛶</button>
    </div>
</div>

<style>
/* Responsive Mobile Controls */
@media (orientation: portrait) and (max-width: 768px) {
    .mobile-control-joystick {
        left: 15px !important;
        bottom: 15px !important;
        width: 120px !important;
        height: 120px !important;
    }
    
    .mobile-control-fire {
        right: 15px !important;
        bottom: 25px !important;
        width: 80px !important;
        height: 80px !important;
    }
    
    #fullscreen-control {
        display: block !important;
    }
}

@media (orientation: landscape) and (max-width: 1024px) {
    .mobile-control-joystick {
        left: 10px !important;
        bottom: 10px !important;
        width: 140px !important;
        height: 140px !important;
    }
    
    .mobile-control-fire {
        right: 10px !important;
        bottom: 10px !important;
        width: 90px !important;
        height: 90px !important;
    }
    
    #fullscreen-control {
        display: block !important;
    }
}

@media (max-width: 480px) {
    .mobile-control-joystick {
        width: 100px !important;
        height: 100px !important;
    }
    
    .mobile-control-fire {
        width: 70px !important;
        height: 70px !important;
    }
}
</style>

<script>
// Best Practice Mobile Game Controls Implementation
// Based on proven open-source patterns

// Enhanced device detection with responsive capabilities
const deviceInfo = {
    isIPhone: /iPhone/.test(navigator.userAgent),
    isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
    isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    isTouch: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    isPortrait: window.innerHeight > window.innerWidth,
    pixelRatio: window.devicePixelRatio || 1,
    
    // Dynamic orientation and size tracking
    updateScreenInfo() {
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;
        this.isPortrait = window.innerHeight > window.innerWidth;
    },
    
    // Get responsive control size based on screen
    getControlScale() {
        const baseSize = Math.min(this.screenWidth, this.screenHeight);
        if (baseSize < 400) return 0.7;
        if (baseSize < 600) return 0.85;
        return 1.0;
    }
};

console.log('Device detected:', deviceInfo);

// Show mobile controls only on touch devices
if (deviceInfo.isTouch) {
    document.getElementById('mobile-controls').style.display = 'block';
    document.getElementById('fullscreen-control').style.display = 'block';
    console.log('📱 Mobile controls enabled');
}

// Responsive control management
function updateMobileControlsLayout() {
    if (!deviceInfo.isTouch) return;
    
    const scale = deviceInfo.getControlScale();
    const joystickControl = document.getElementById('left-control');
    const fireControl = document.getElementById('right-control');
    const joystickCanvas = document.getElementById('joystick-canvas');
    const fireCanvas = document.getElementById('fire-canvas');
    
    // Update control sizes based on screen size
    const joystickSize = Math.floor(150 * scale);
    const fireSize = Math.floor(100 * scale);
    
    if (joystickControl) {
        joystickControl.style.width = joystickSize + 'px';
        joystickControl.style.height = joystickSize + 'px';
        joystickCanvas.width = joystickSize;
        joystickCanvas.height = joystickSize;
    }
    
    if (fireControl) {
        fireControl.style.width = fireSize + 'px';
        fireControl.style.height = fireSize + 'px';
        fireCanvas.width = fireSize;
        fireCanvas.height = fireSize;
    }
    
    // Reinitialize controls with new sizes
    if (window.virtualJoystick) {
        window.virtualJoystick.centerX = joystickSize / 2;
        window.virtualJoystick.centerY = joystickSize / 2;
        window.virtualJoystick.maxRadius = joystickSize / 2 - 10;
        window.virtualJoystick.draw();
    }
    
    if (window.fireButton) {
        window.fireButton.centerX = fireSize / 2;
        window.fireButton.centerY = fireSize / 2;
        window.fireButton.radius = fireSize / 2 - 10;
        window.fireButton.draw();
    }
}

// Fullscreen functionality for immersive mobile experience
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        canvas.requestFullscreen().then(() => {
            console.log('📱 Entered fullscreen mode');
            deviceInfo.updateScreenInfo();
            updateMobileControlsLayout();
        }).catch(err => {
            console.log('Fullscreen failed:', err);
        });
    } else {
        document.exitFullscreen().then(() => {
            console.log('📱 Exited fullscreen mode');
            deviceInfo.updateScreenInfo();
            updateMobileControlsLayout();
        });
    }
}

// Enhanced window event handlers
window.addEventListener('resize', () => {
    deviceInfo.updateScreenInfo();
    updateMobileControlsLayout();
    console.log('📱 Screen resized:', deviceInfo.screenWidth, 'x', deviceInfo.screenHeight);
});

window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        deviceInfo.updateScreenInfo();
        updateMobileControlsLayout();
        console.log('📱 Orientation changed to:', deviceInfo.isPortrait ? 'Portrait' : 'Landscape');
    }, 100);
});

// Fullscreen button event
document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);

// Responsive game canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Enhanced responsive canvas sizing
function resizeCanvas() {
    const container = canvas.parentElement;
    let targetWidth, targetHeight;
    
    if (deviceInfo.isMobile) {
        if (deviceInfo.isPortrait) {
            // Portrait mode: Optimize for portrait gameplay
            targetWidth = Math.min(deviceInfo.screenWidth * 0.95, 600);
            targetHeight = Math.min(deviceInfo.screenHeight * 0.55, 400);
        } else {
            // Landscape mode: Use more screen space
            targetWidth = Math.min(deviceInfo.screenWidth * 0.9, 800);
            targetHeight = Math.min(deviceInfo.screenHeight * 0.8, 600);
        }
    } else {
        // Desktop mode: Default sizing
        targetWidth = 800;
        targetHeight = 600;
    }
    
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    canvas.style.width = targetWidth + 'px';
    canvas.style.height = targetHeight + 'px';
    
    console.log(`📱 Canvas resized to: ${targetWidth}x${targetHeight}`);
}

// iPhone and mobile-specific optimizations
if (deviceInfo.isTouch) {
    console.log('📱 Touch device optimizations applied');
    canvas.style.transform = 'translateZ(0)';
    canvas.style.webkitTransform = 'translateZ(0)';
    canvas.style.willChange = 'transform';
    canvas.style.touchAction = 'none'; // Prevent scrolling on touch
    
    // Initial responsive sizing
    resizeCanvas();
    
    // Prevent context menu on long press
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    
    // Prevent default touch behaviors
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
}

// Enhanced resize handler with canvas updates
const originalResizeHandler = window.addEventListener;
window.addEventListener('resize', () => {
    deviceInfo.updateScreenInfo();
    resizeCanvas();
    updateMobileControlsLayout();
    console.log('📱 Screen resized:', deviceInfo.screenWidth, 'x', deviceInfo.screenHeight);
});

window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        deviceInfo.updateScreenInfo();
        resizeCanvas();
        updateMobileControlsLayout();
        console.log('📱 Orientation changed to:', deviceInfo.isPortrait ? 'Portrait' : 'Landscape');
    }, 100);
});

// Virtual Joystick Implementation (Best Practice Pattern)
class VirtualJoystick {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.centerX = canvas.width / 2;
        this.centerY = canvas.height / 2;
        this.maxRadius = Math.min(canvas.width, canvas.height) / 2 - 10;
        this.knobRadius = 15;
        this.deadZone = 20;
        
        this.pressed = false;
        this.knobX = this.centerX;
        this.knobY = this.centerY;
        
        this.callbacks = options.callbacks || {};
        
        this.setupEventListeners();
        this.draw();
    }
    
    setupEventListeners() {
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleEnd(e), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => this.handleEnd(e), { passive: false });
        
        // Mouse events for desktop testing
        this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleEnd(e));
    }
    
    getEventPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }
    
    handleStart(e) {
        e.preventDefault();
        this.pressed = true;
        const pos = this.getEventPos(e);
        this.updateKnobPosition(pos.x, pos.y);
        
        if (this.callbacks.onStart) {
            this.callbacks.onStart(this.getValues());
        }
    }
    
    handleMove(e) {
        if (!this.pressed) return;
        e.preventDefault();
        
        const pos = this.getEventPos(e);
        this.updateKnobPosition(pos.x, pos.y);
        
        if (this.callbacks.onMove) {
            this.callbacks.onMove(this.getValues());
        }
    }
    
    handleEnd(e) {
        if (!this.pressed) return;
        e.preventDefault();
        
        this.pressed = false;
        this.knobX = this.centerX;
        this.knobY = this.centerY;
        this.draw();
        
        if (this.callbacks.onEnd) {
            this.callbacks.onEnd(this.getValues());
        }
    }
    
    updateKnobPosition(x, y) {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= this.maxRadius) {
            this.knobX = x;
            this.knobY = y;
        } else {
            const angle = Math.atan2(dy, dx);
            this.knobX = this.centerX + Math.cos(angle) * this.maxRadius;
            this.knobY = this.centerY + Math.sin(angle) * this.maxRadius;
        }
        
        this.draw();
    }
    
    getValues() {
        const dx = this.knobX - this.centerX;
        const dy = this.knobY - this.centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Apply dead zone
        if (distance <= this.deadZone) {
            return { x: 0, y: 0, distance: 0, angle: 0 };
        }
        
        // Normalize values between -1 and 1
        const normalizedX = dx / this.maxRadius;
        const normalizedY = dy / this.maxRadius;
        const angle = Math.atan2(dy, dx);
        
        return {
            x: Math.max(-1, Math.min(1, normalizedX)),
            y: Math.max(-1, Math.min(1, normalizedY)),
            distance: Math.min(distance / this.maxRadius, 1),
            angle: angle
        };
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw outer circle (background)
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, this.maxRadius, 0, 2 * Math.PI);
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        this.ctx.fill();
        this.ctx.strokeStyle = '#00ff00';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // Draw dead zone
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, this.deadZone, 0, 2 * Math.PI);
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.05)';
        this.ctx.fill();
        this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.stroke();
        
        // Draw knob
        this.ctx.beginPath();
        this.ctx.arc(this.knobX, this.knobY, this.knobRadius, 0, 2 * Math.PI);
        this.ctx.fillStyle = this.pressed ? 'rgba(0, 255, 0, 0.6)' : 'rgba(0, 255, 0, 0.4)';
        this.ctx.fill();
        this.ctx.strokeStyle = '#00ff00';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // Draw center dot
        this.ctx.beginPath();
        this.ctx.arc(this.knobX, this.knobY, 3, 0, 2 * Math.PI);
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fill();
    }
}

// Fire Button Implementation
class FireButton {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.centerX = canvas.width / 2;
        this.centerY = canvas.height / 2;
        this.radius = Math.min(canvas.width, canvas.height) / 2 - 5;
        
        this.pressed = false;
        this.callbacks = options.callbacks || {};
        
        this.setupEventListeners();
        this.draw();
    }
    
    setupEventListeners() {
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.handleStart(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleEnd(e), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => this.handleEnd(e), { passive: false });
        
        // Mouse events for desktop testing
        this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleEnd(e));
    }
    
    handleStart(e) {
        e.preventDefault();
        this.pressed = true;
        this.draw();
        
        // Haptic feedback
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
        
        if (this.callbacks.onPress) {
            this.callbacks.onPress();
        }
    }
    
    handleEnd(e) {
        if (!this.pressed) return;
        e.preventDefault();
        
        this.pressed = false;
        this.draw();
        
        if (this.callbacks.onRelease) {
            this.callbacks.onRelease();
        }
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw button background
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI);
        
        if (this.pressed) {
            this.ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
        } else {
            const gradient = this.ctx.createRadialGradient(
                this.centerX, this.centerY, 0,
                this.centerX, this.centerY, this.radius
            );
            gradient.addColorStop(0, 'rgba(255, 255, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 0, 0.1)');
            this.ctx.fillStyle = gradient;
        }
        
        this.ctx.fill();
        this.ctx.strokeStyle = '#ffff00';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
        
        // Draw fire icon
        this.ctx.fillStyle = '#ffff00';
        this.ctx.font = 'bold 24px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('🔥', this.centerX, this.centerY);
    }
}

// Enhanced game state with performance monitoring
const gameState = {
    player: { x: 50, y: 300, width: 20, height: 15, health: 100, speed: 4 },
    enemies: [],
    bullets: [],
    particles: [],
    terrain: {
        background: [],    // Far mountains (slowest parallax)
        midground: [],     // Rolling hills (medium parallax) 
        foreground: []     // Detailed surface (fastest parallax)
    },
    obstacles: {
        destructible: [],  // Breakable terrain objects
        hazards: [],       // Environmental dangers
        platforms: []      // Moving platforms
    },
    score: 0,
    lives: 3,
    keys: {},
    movement: { x: 0, y: 0 },
    gameRunning: false,
    lastTime: performance.now(),
    scrollOffset: 0,    // For parallax scrolling
    
    // Performance monitoring
    performance: {
        frameCount: 0,
        lastFPSTime: performance.now(),
        currentFPS: 60,
        averageFPS: 60,
        frameTime: 16.67,
        renderTime: 0,
        updateTime: 0,
        lastFrameStart: 0,
        
        // Performance thresholds
        minFPS: 30,
        targetFPS: 60,
        adaptiveQuality: true,
        qualityLevel: 1.0 // 1.0 = full quality, 0.5 = reduced quality
    }
};

// Initialize mobile controls
let virtualJoystick, fireButton;

if (deviceInfo.isTouch) {
    const joystickCanvas = document.getElementById('joystick-canvas');
    const fireCanvas = document.getElementById('fire-canvas');
    
    virtualJoystick = new VirtualJoystick(joystickCanvas, {
        callbacks: {
            onMove: (values) => {
                gameState.movement.x = values.x;
                gameState.movement.y = values.y;
            },
            onEnd: () => {
                gameState.movement.x = 0;
                gameState.movement.y = 0;
            }
        }
    });
    
    fireButton = new FireButton(fireCanvas, {
        callbacks: {
            onPress: () => {
                fireBullet();
            }
        }
    });
}

// Initialize Blood Money-style multi-layered terrain
function initializeTerrain() {
    // Background mountains (slowest parallax - 0.1x speed)
    for (let x = 0; x < canvas.width * 2; x += 20) {
        const height = 80 + Math.sin(x * 0.01) * 30 + Math.sin(x * 0.003) * 20;
        gameState.terrain.background.push({
            x: x,
            height: height,
            type: 'mountain'
        });
    }
    
    // Midground hills (medium parallax - 0.3x speed)
    for (let x = 0; x < canvas.width * 1.5; x += 15) {
        const baseHeight = 40 + Math.sin(x * 0.02) * 15;
        const variation = Math.sin(x * 0.008) * 10 + Math.sin(x * 0.015) * 8;
        gameState.terrain.midground.push({
            x: x,
            height: baseHeight + variation,
            type: 'hill'
        });
    }
    
    // Foreground detailed surface (full speed - 1.0x)
    for (let x = 0; x < canvas.width + 100; x += 8) {
        const baseHeight = 20 + Math.sin(x * 0.05) * 8;
        const detail = Math.sin(x * 0.1) * 3 + Math.sin(x * 0.2) * 2;
        const rocks = Math.random() > 0.7 ? Math.random() * 5 : 0;
        gameState.terrain.foreground.push({
            x: x,
            height: baseHeight + detail + rocks,
            type: 'surface',
            hasRocks: rocks > 0
        });
    }
}

initializeTerrain();

// Initialize Blood Money-style dynamic obstacles
function initializeObstacles() {
    // Destructible terrain objects
    for (let i = 0; i < 8; i++) {
        gameState.obstacles.destructible.push({
            x: 150 + i * 120 + Math.random() * 40,
            y: 200 + Math.random() * 200,
            width: 25,
            height: 30,
            health: 3,
            type: Math.random() > 0.5 ? 'rock' : 'crystal',
            destroyed: false
        });
    }
    
    // Environmental hazards
    for (let i = 0; i < 6; i++) {
        gameState.obstacles.hazards.push({
            x: 200 + i * 140,
            y: 100 + Math.random() * 300,
            width: 15,
            height: 80,
            type: 'laser',
            active: true,
            cycleTime: 2000 + Math.random() * 1000,
            damage: 25
        });
    }
    
    // Moving platforms
    for (let i = 0; i < 4; i++) {
        gameState.obstacles.platforms.push({
            x: 300 + i * 200,
            y: 150 + Math.sin(i) * 100,
            width: 60,
            height: 12,
            speed: 0.5 + Math.random() * 1,
            direction: Math.random() > 0.5 ? 1 : -1,
            range: 80,
            originY: 150 + Math.sin(i) * 100
        });
    }
}

initializeObstacles();

// Initialize enemies
for (let i = 0; i < 5; i++) {
    gameState.enemies.push({
        x: 200 + i * 80,
        y: 30 + Math.sin(i * 2) * 40,
        width: 15,
        height: 15,
        speed: 0.5 + Math.random() * 1.5,
        health: 3,
        type: Math.floor(Math.random() * 3)
    });
}

// Keyboard input handling
document.addEventListener('keydown', (e) => {
    gameState.keys[e.key.toLowerCase()] = true;
    if (e.key === ' ') {
        e.preventDefault();
        fireBullet();
    }
});

document.addEventListener('keyup', (e) => {
    gameState.keys[e.key.toLowerCase()] = false;
});

// Game functions
function fireBullet() {
    gameState.bullets.push({
        x: gameState.player.x + gameState.player.width,
        y: gameState.player.y + gameState.player.height / 2,
        speed: 6,
        damage: 1
    });
}

function updatePlayer() {
    // Keyboard movement
    let moveX = 0, moveY = 0;
    
    if (gameState.keys['arrowleft'] || gameState.keys['a']) moveX -= 1;
    if (gameState.keys['arrowright'] || gameState.keys['d']) moveX += 1;
    if (gameState.keys['arrowup'] || gameState.keys['w']) moveY -= 1;
    if (gameState.keys['arrowdown'] || gameState.keys['s']) moveY += 1;
    
    // Mobile joystick movement
    if (deviceInfo.isTouch && virtualJoystick) {
        moveX += gameState.movement.x;
        moveY += gameState.movement.y;
    }
    
    // Apply movement
    gameState.player.x += moveX * gameState.player.speed;
    gameState.player.y += moveY * gameState.player.speed;
    
    // Keep player in bounds
    gameState.player.x = Math.max(0, Math.min(canvas.width - gameState.player.width, gameState.player.x));
    gameState.player.y = Math.max(0, Math.min(canvas.height - gameState.player.height, gameState.player.y));
    
    // Collision detection with obstacles
    checkPlayerObstacleCollisions();
}

function checkPlayerObstacleCollisions() {
    // Check collision with destructible objects
    gameState.obstacles.destructible.forEach(obj => {
        if (!obj.destroyed &&
            gameState.player.x < obj.x + obj.width &&
            gameState.player.x + gameState.player.width > obj.x &&
            gameState.player.y < obj.y + obj.height &&
            gameState.player.y + gameState.player.height > obj.y) {
            
            // Push player away from obstacle
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            const playerCenterX = gameState.player.x + gameState.player.width / 2;
            const playerCenterY = gameState.player.y + gameState.player.height / 2;
            
            const dx = playerCenterX - centerX;
            const dy = playerCenterY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                gameState.player.x += (dx / distance) * 2;
                gameState.player.y += (dy / distance) * 2;
            }
        }
    });
    
    // Check collision with active laser hazards
    gameState.obstacles.hazards.forEach(hazard => {
        if (hazard.active && hazard.type === 'laser' &&
            gameState.player.x < hazard.x + 4 &&
            gameState.player.x + gameState.player.width > hazard.x &&
            gameState.player.y < hazard.y + hazard.height &&
            gameState.player.y + gameState.player.height > hazard.y) {
            
            // Player hit by laser - take damage
            gameState.player.health -= hazard.damage;
            
            // Create damage particles
            for (let p = 0; p < 10; p++) {
                gameState.particles.push({
                    x: gameState.player.x + gameState.player.width / 2,
                    y: gameState.player.y + gameState.player.height / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 25,
                    color: '#ff4444'
                });
            }
            
            // Push player away from laser
            gameState.player.x -= 5;
            
            if (gameState.player.health <= 0) {
                gameState.lives--;
                gameState.player.health = 100;
                if (gameState.lives <= 0) {
                    console.log('Game Over!');
                    // Could trigger game over screen here
                }
            }
        }
    });
}

function updateEnemies() {
    gameState.enemies.forEach((enemy, i) => {
        enemy.x -= enemy.speed;
        enemy.y += Math.sin(Date.now() * 0.001 + i) * 0.5;
        
        if (enemy.x < -enemy.width) {
            enemy.x = canvas.width + 20;
            enemy.y = 30 + Math.random() * 300;
            enemy.health = 3;
        }
    });
}

function updateBullets() {
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const bullet = gameState.bullets[i];
        bullet.x += bullet.speed;
        
        if (bullet.x > canvas.width) {
            gameState.bullets.splice(i, 1);
            continue;
        }
        
        // Collision with enemies
        for (let j = 0; j < gameState.enemies.length; j++) {
            const enemy = gameState.enemies[j];
            if (bullet.x < enemy.x + enemy.width &&
                bullet.x + 8 > enemy.x &&
                bullet.y < enemy.y + enemy.height &&
                bullet.y + 2 > enemy.y) {
                
                // Hit! Create particles
                for (let p = 0; p < 5; p++) {
                    gameState.particles.push({
                        x: enemy.x + enemy.width / 2,
                        y: enemy.y + enemy.height / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 20,
                        color: '#ffff00'
                    });
                }
                
                enemy.health--;
                gameState.bullets.splice(i, 1);
                gameState.score += 10;
                
                if (enemy.health <= 0) {
                    enemy.x = canvas.width + Math.random() * 100;
                    enemy.y = 30 + Math.random() * 300;
                    enemy.health = 3;
                    gameState.score += 50;
                }
                break;
            }
        }
        
        // Collision with destructible obstacles
        for (let j = 0; j < gameState.obstacles.destructible.length; j++) {
            const obj = gameState.obstacles.destructible[j];
            if (!obj.destroyed &&
                bullet.x < obj.x + obj.width &&
                bullet.x + 8 > obj.x &&
                bullet.y < obj.y + obj.height &&
                bullet.y + 2 > obj.y) {
                
                // Hit destructible object
                obj.health--;
                gameState.bullets.splice(i, 1);
                
                // Create destruction particles
                const particleColor = obj.type === 'rock' ? '#808080' : '#88ccff';
                for (let p = 0; p < 8; p++) {
                    gameState.particles.push({
                        x: obj.x + obj.width / 2,
                        y: obj.y + obj.height / 2,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 30,
                        color: particleColor
                    });
                }
                
                if (obj.health <= 0) {
                    obj.destroyed = true;
                    gameState.score += obj.type === 'crystal' ? 100 : 50;
                }
                break;
            }
        }
    }
}

function updateParticles() {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const particle = gameState.particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        
        if (particle.life <= 0) {
            gameState.particles.splice(i, 1);
        }
    }
}

function updateTerrain() {
    gameState.scrollOffset += 1;
    
    // Update background mountains (slowest parallax)
    gameState.terrain.background.forEach(t => {
        t.x -= 0.1; // Very slow movement
        if (t.x < -40) {
            t.x = canvas.width + 20;
            t.height = 80 + Math.sin(Date.now() * 0.0005 + t.x * 0.01) * 30 + Math.sin(t.x * 0.003) * 20;
        }
    });
    
    // Update midground hills (medium parallax)
    gameState.terrain.midground.forEach(t => {
        t.x -= 0.3; // Medium speed
        if (t.x < -30) {
            t.x = canvas.width + 15;
            const baseHeight = 40 + Math.sin(t.x * 0.02) * 15;
            const variation = Math.sin(Date.now() * 0.001 + t.x * 0.008) * 10;
            t.height = baseHeight + variation;
        }
    });
    
    // Update foreground surface (full speed)
    gameState.terrain.foreground.forEach(t => {
        t.x -= 1; // Full speed
        if (t.x < -16) {
            t.x = canvas.width + 8;
            const baseHeight = 20 + Math.sin(t.x * 0.05) * 8;
            const detail = Math.sin(Date.now() * 0.002 + t.x * 0.1) * 3;
            const rocks = Math.random() > 0.7 ? Math.random() * 5 : 0;
            t.height = baseHeight + detail + rocks;
            t.hasRocks = rocks > 0;
        }
    });
}

function updateObstacles() {
    const currentTime = Date.now();
    
    // Update destructible objects
    gameState.obstacles.destructible.forEach(obj => {
        obj.x -= 1; // Move with foreground
        if (obj.x < -obj.width) {
            obj.x = canvas.width + Math.random() * 100;
            obj.y = 200 + Math.random() * 200;
            obj.health = 3;
            obj.destroyed = false;
        }
    });
    
    // Update environmental hazards
    gameState.obstacles.hazards.forEach(hazard => {
        hazard.x -= 1; // Move with scene
        if (hazard.x < -hazard.width) {
            hazard.x = canvas.width + Math.random() * 100;
            hazard.y = 100 + Math.random() * 300;
        }
        
        // Laser cycling
        if (hazard.type === 'laser') {
            const cycle = (currentTime % hazard.cycleTime) / hazard.cycleTime;
            hazard.active = cycle < 0.7; // Active 70% of the time
        }
    });
    
    // Update moving platforms
    gameState.obstacles.platforms.forEach(platform => {
        platform.x -= 0.5; // Slower movement than foreground
        if (platform.x < -platform.width) {
            platform.x = canvas.width + Math.random() * 50;
            platform.originY = 150 + Math.random() * 200;
            platform.y = platform.originY;
        }
        
        // Vertical movement
        platform.y += platform.speed * platform.direction;
        if (Math.abs(platform.y - platform.originY) > platform.range) {
            platform.direction *= -1;
        }
    });
}

// Render functions
function render() {
    // Background
    ctx.fillStyle = '#001100';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Starfield
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 20; i++) {
        const x = ((Date.now() * 0.05 + i * 23) % canvas.width);
        const y = (i * 37) % canvas.height;
        ctx.fillRect(x, y, 1, 1);
    }
    
    // Multi-layered Blood Money-style terrain
    
    // Background mountains (dark silhouettes)
    ctx.fillStyle = '#001a00';
    gameState.terrain.background.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(t.x, canvas.height);
        ctx.lineTo(t.x, canvas.height - t.height);
        ctx.lineTo(t.x + 20, canvas.height - t.height);
        ctx.lineTo(t.x + 20, canvas.height);
        ctx.closePath();
        ctx.fill();
        
        // Mountain peaks detail
        ctx.fillStyle = '#002200';
        ctx.fillRect(t.x + 5, canvas.height - t.height - 5, 10, 5);
        ctx.fillStyle = '#001a00';
    });
    
    // Midground hills (medium green)
    ctx.fillStyle = '#002a00';
    gameState.terrain.midground.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(t.x, canvas.height);
        ctx.lineTo(t.x, canvas.height - t.height);
        // Smooth hill curves
        ctx.quadraticCurveTo(t.x + 7.5, canvas.height - t.height - 3, t.x + 15, canvas.height - t.height);
        ctx.lineTo(t.x + 15, canvas.height);
        ctx.closePath();
        ctx.fill();
        
        // Hill highlights
        ctx.fillStyle = '#003600';
        ctx.fillRect(t.x + 3, canvas.height - t.height + 2, 9, 3);
        ctx.fillStyle = '#002a00';
    });
    
    // Foreground detailed surface (brightest green with details)
    gameState.terrain.foreground.forEach(t => {
        ctx.fillStyle = '#003300';
        ctx.fillRect(t.x, canvas.height - t.height, 8, t.height);
        
        // Surface details and rocks
        if (t.hasRocks) {
            ctx.fillStyle = '#404040';
            ctx.fillRect(t.x + 2, canvas.height - t.height - 2, 4, 2);
        }
        
        // Surface texture
        ctx.fillStyle = '#004400';
        ctx.fillRect(t.x + 1, canvas.height - t.height + 1, 6, 2);
    });
    
    // Blood Money-style Dynamic Obstacles
    
    // Destructible terrain objects
    gameState.obstacles.destructible.forEach(obj => {
        if (obj.destroyed) return;
        
        if (obj.type === 'rock') {
            // Rocky outcroppings
            ctx.fillStyle = '#606060';
            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            ctx.fillStyle = '#808080';
            ctx.fillRect(obj.x + 2, obj.y + 2, obj.width - 4, obj.height - 4);
            // Rock highlights
            ctx.fillStyle = '#a0a0a0';
            ctx.fillRect(obj.x + 4, obj.y + 4, 6, 4);
        } else {
            // Crystal formations
            ctx.fillStyle = '#004488';
            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(obj.x + 3, obj.y + 3, obj.width - 6, obj.height - 6);
            // Crystal glow
            ctx.fillStyle = '#88ccff';
            ctx.fillRect(obj.x + 8, obj.y + 8, 8, 8);
        }
        
        // Damage indicators
        if (obj.health < 3) {
            ctx.fillStyle = '#ff4444';
            for (let i = 0; i < (3 - obj.health) * 3; i++) {
                const fx = obj.x + Math.random() * obj.width;
                const fy = obj.y + Math.random() * obj.height;
                ctx.fillRect(fx, fy, 2, 2);
            }
        }
    });
    
    // Environmental hazards
    gameState.obstacles.hazards.forEach(hazard => {
        if (hazard.type === 'laser') {
            if (hazard.active) {
                // Laser beam
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(hazard.x, hazard.y, 4, hazard.height);
                // Laser glow
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(hazard.x - 2, hazard.y, 8, hazard.height);
                // Laser core
                ctx.fillStyle = '#ffaaaa';
                ctx.fillRect(hazard.x + 1, hazard.y, 2, hazard.height);
            }
            
            // Laser emitter
            ctx.fillStyle = '#333333';
            ctx.fillRect(hazard.x - 3, hazard.y - 10, 10, 8);
            ctx.fillStyle = hazard.active ? '#ff4444' : '#444444';
            ctx.fillRect(hazard.x - 1, hazard.y - 8, 6, 4);
        }
    });
    
    // Moving platforms
    gameState.obstacles.platforms.forEach(platform => {
        // Platform base
        ctx.fillStyle = '#666666';
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        // Platform surface
        ctx.fillStyle = '#888888';
        ctx.fillRect(platform.x + 2, platform.y, platform.width - 4, 4);
        // Platform lights
        ctx.fillStyle = '#00ff00';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(platform.x + 8 + i * 16, platform.y + 2, 4, 2);
        }
        // Platform shadow/depth
        ctx.fillStyle = '#444444';
        ctx.fillRect(platform.x, platform.y + platform.height - 2, platform.width, 2);
    });
    
    // Player
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);
    
    // Player details
    ctx.fillStyle = '#88ff88';
    ctx.fillRect(gameState.player.x + 2, gameState.player.y + 2, 16, 11);
    ctx.fillStyle = '#0088ff';
    ctx.fillRect(gameState.player.x - 3, gameState.player.y + 6, 6, 3);
    
    // Enhanced desktop-quality enemies with detailed sprites
    gameState.enemies.forEach((enemy, i) => {
        let baseColor, brightColor, darkColor;
        switch (enemy.type) {
            case 0: 
                baseColor = '#aa0000'; brightColor = '#ff0000'; darkColor = '#660000'; 
                break;
            case 1: 
                baseColor = '#aa4400'; brightColor = '#ff8800'; darkColor = '#662200'; 
                break;
            case 2: 
                baseColor = '#aa0044'; brightColor = '#ff0088'; darkColor = '#660022'; 
                break;
        }
        
        // Enemy ship main body
        ctx.fillStyle = baseColor;
        ctx.fillRect(enemy.x + 1, enemy.y + 2, enemy.width - 2, enemy.height - 4);
        
        // Enemy ship nose (pointing left)
        ctx.fillStyle = brightColor;
        ctx.fillRect(enemy.x, enemy.y + 4, 4, enemy.height - 8);
        
        // Enemy ship wings
        ctx.fillStyle = darkColor;
        ctx.fillRect(enemy.x + 8, enemy.y, 6, 3);
        ctx.fillRect(enemy.x + 8, enemy.y + enemy.height - 3, 6, 3);
        
        // Enemy engine glow
        const enemyGlow = 0.4 + Math.sin(Date.now() * 0.03 + enemy.x * 0.01) * 0.3;
        ctx.fillStyle = `rgba(255, 100, 0, ${enemyGlow})`;
        ctx.fillRect(enemy.x + enemy.width, enemy.y + 5, 4, enemy.height - 10);
        
        // Enemy ship details
        ctx.fillStyle = brightColor;
        ctx.fillRect(enemy.x + 3, enemy.y + 6, enemy.width - 6, 2);
        
        // Enemy weapon pods
        ctx.fillStyle = '#ffaa00';
        ctx.fillRect(enemy.x + 2, enemy.y + 2, 2, 2);
        ctx.fillRect(enemy.x + 2, enemy.y + enemy.height - 4, 2, 2);
        
        // Enemy cockpit/sensor
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(enemy.x + 1, enemy.y + 7, 2, 1);
    });
    
    // Enhanced desktop-quality bullets with glow effects
    gameState.bullets.forEach(bullet => {
        // Bullet core
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(bullet.x, bullet.y, 8, 2);
        
        // Bullet glow/trail
        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
        ctx.fillRect(bullet.x - 2, bullet.y - 1, 12, 4);
        
        // Bullet highlight
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(bullet.x + 2, bullet.y, 4, 1);
        
        // Energy trail particles
        for (let i = 1; i <= 3; i++) {
            const trailAlpha = 0.3 / i;
            ctx.fillStyle = `rgba(255, 255, 0, ${trailAlpha})`;
            ctx.fillRect(bullet.x - i * 3, bullet.y, 2, 2);
        }
    });
    
    // Particles
    gameState.particles.forEach(particle => {
        const alpha = particle.life / 20;
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(particle.x, particle.y, 2, 2);
        ctx.globalAlpha = 1;
    });
    
    // UI
    ctx.fillStyle = '#00ff00';
    ctx.font = '16px Courier New';
    ctx.fillText(`Score: ${gameState.score}`, 10, 30);
    ctx.fillText(`Health: ${gameState.player.health}`, 10, 50);
    ctx.fillText(`Lives: ${gameState.lives}`, 10, 70);
}

// Enhanced game loop with performance monitoring and adaptive quality
function gameLoop(currentTime) {
    if (!gameState.gameRunning) return;
    
    const perf = gameState.performance;
    perf.lastFrameStart = currentTime;
    const deltaTime = currentTime - gameState.lastTime;
    gameState.lastTime = currentTime;
    
    // Update FPS calculation
    perf.frameCount++;
    if (currentTime - perf.lastFPSTime >= 1000) {
        perf.currentFPS = perf.frameCount;
        perf.averageFPS = (perf.averageFPS * 0.9) + (perf.currentFPS * 0.1);
        perf.frameCount = 0;
        perf.lastFPSTime = currentTime;
        
        // Adaptive quality adjustment
        if (perf.adaptiveQuality) {
            if (perf.averageFPS < perf.minFPS && perf.qualityLevel > 0.3) {
                perf.qualityLevel = Math.max(0.3, perf.qualityLevel - 0.1);
                console.log(`🔧 Reducing quality to ${(perf.qualityLevel * 100).toFixed(0)}% (FPS: ${perf.averageFPS.toFixed(1)})`);
            } else if (perf.averageFPS > perf.targetFPS - 5 && perf.qualityLevel < 1.0) {
                perf.qualityLevel = Math.min(1.0, perf.qualityLevel + 0.05);
                console.log(`✨ Increasing quality to ${(perf.qualityLevel * 100).toFixed(0)}% (FPS: ${perf.averageFPS.toFixed(1)})`);
            }
        }
    }
    
    // Performance-optimized updates
    const updateStart = performance.now();
    updatePlayer();
    updateEnemies();
    updateBullets();
    updateParticles();
    updateTerrain();
    updateObstacles();
    perf.updateTime = performance.now() - updateStart;
    
    // Performance-optimized rendering
    const renderStart = performance.now();
    render();
    perf.renderTime = performance.now() - renderStart;
    
    // Update HUD with performance info
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('lives').textContent = gameState.lives;
    document.getElementById('health').textContent = gameState.player.health;
    
    // Frame time tracking
    perf.frameTime = performance.now() - perf.lastFrameStart;
    
    // Optimized animation frame request
    if (!document.hidden) {
        requestAnimationFrame(gameLoop);
    } else {
        // Reduce frame rate when tab is not visible
        setTimeout(() => requestAnimationFrame(gameLoop), 100);
    }
}

// Initialize game with performance monitoring
function initGame() {
    console.log('🎮 Initializing enhanced Bolamiga with performance monitoring...');
    
    // Performance monitoring setup
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            console.log('⏸️ Game paused (tab hidden)');
        } else {
            console.log('▶️ Game resumed (tab visible)');
            gameState.lastTime = performance.now(); // Reset time to prevent frame skip
        }
    });

    // Add performance debug controls
    document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'p' && e.shiftKey) {
            gameState.performance.adaptiveQuality = !gameState.performance.adaptiveQuality;
            console.log(`🔧 Adaptive quality: ${gameState.performance.adaptiveQuality ? 'ON' : 'OFF'}`);
        }
        if (e.key.toLowerCase() === 'f' && e.shiftKey && deviceInfo.isMobile) {
            toggleFullscreen();
        }
    });
    
    // Test initial render
    ctx.fillStyle = '#002200';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#00ff00';
    ctx.font = '16px monospace';
    ctx.fillText('BOLAMIGA - ENHANCED EDITION', 50, 50);
    ctx.fillText('Loading performance systems...', 50, 80);
    
    console.log('💡 Press Shift+P to toggle adaptive quality');
    console.log('📱 Press Shift+F for fullscreen (mobile)');
    
    // Start game
    setTimeout(() => {
        gameState.gameRunning = true;
        gameLoop(performance.now());
        console.log('🚀 Enhanced game started with performance monitoring!');
    }, 1500);
}

// Prevent scrolling on mobile
document.addEventListener('touchmove', (e) => {
    if (e.target.closest('#mobile-controls')) {
        e.preventDefault();
    }
}, { passive: false });

// Start when page loads
window.addEventListener('load', initGame);

console.log('📱 Best practice mobile controls loaded');
</script>

<style>
/* Mobile Control Styling */
#mobile-controls {
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
}

#left-control, #right-control {
    touch-action: none;
}

/* Prevent text selection and context menus on mobile controls */
#joystick-canvas, #fire-canvas {
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Responsive adjustments */
@media (max-height: 600px) {
    #left-control, #right-control {
        width: 120px;
        height: 120px;
        bottom: 10px;
    }
    
    #joystick-canvas, #fire-canvas {
        width: 120px;
        height: 120px;
    }
    
    #left-control {
        left: 10px;
    }
    
    #right-control {
        right: 10px;
        width: 80px;
        height: 80px;
    }
    
    #fire-canvas {
        width: 80px;
        height: 80px;
    }
}

@media (max-width: 480px) {
    #left-control {
        width: 130px;
        height: 130px;
    }
    
    #joystick-canvas {
        width: 130px;
        height: 130px;
    }
    
    #right-control {
        width: 90px;
        height: 90px;
    }
    
    #fire-canvas {
        width: 90px;
        height: 90px;
    }
}
</style>
{% endblock %}